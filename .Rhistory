rownames(homo_exclu) <- c('AA', 'AC', 'CC', 'miss')
colnames(homo_exclu) <- c('AA', 'AC', 'CC', 'miss')
hetero_exclu <- matrix(c(1,0,0,1,0,1,0,
0,0,0,0,0,1,0,
0,0,1,0,1,1,0,
1,0,0,1,0,1,0,
0,0,1,0,1,1,0,
1,1,1,1,1,2,1,
0,0,0,0,0,1,0), nrow = 7, ncol = 7)
rownames(hetero_exclu) <- c('AA', 'AB', 'BB', 'AC', 'BC', 'CC', 'miss')
colnames(hetero_exclu) <- c('AA', 'AB', 'BB', 'AC', 'BC', 'CC', 'miss')
off <- 1
cl <- makeCluster(detectCores()-1)
# registerDoParallel(cl)
registerDoSNOW(cl)
iterations <- nrow(offspring)
pb <- txtProgressBar(min = 0, max = iterations, ">((Â°>")
progress <- function(n) {setTxtProgressBar(pb, n)}
opts <- list(progress = progress)
tmp <- offspring[off,, drop = F]
# Create temporary results
res <- matrix(NA, nrow = (nrow(sire)*nrow(dam)), ncol = 4)
colnames(res) <- c('sire', 'dam', 'score_exclu', 'P_mendel')
res[,1] <- rep(rownames(sire), each = nrow(dam))
res[,2] <- rep(rownames(dam), times = nrow(sire))
# Lielihood tables
table_like <- vector('list', x.col)
off_geno <- strsplit(tmp, split = "/", fixed = T)
for (i in 1:length(tmp)) {
if (off_geno[[i]][1]==off_geno[[i]][2]) {
fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
table_like[[i]] <- matrix(c(1,0.5,e,fa,0.5,0.25,e,0.5*fa,e,e,e,e,fa,0.5*fa,e,fa*fa), nrow = 4, ncol = 4)
} else {
fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
fb <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][2]))]
fb <- ifelse(test = (fb==0|is.na(fb)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fb)
table_like[[i]] <- matrix(c(e,0.5,1,e,0.5,e,fb,
0.5,0.5,0.5,0.25,0.5,e,0.5*(fa+fb),
1,0.5,e,0.5,e,e,fa,
e,0.25,0.5,e,0.25,e,0.5*fb,
0.5,0.25,e,0.25,e,e,0.5*fb,
e,e,e,e,e,e,e,
fb,0.5*(fa+fb),fa,0.5*fb,0.5*fa,e,2*fa*fb), nrow = 7, ncol = 7)
}
}
t <- foreach(n = 1:nrow(res), .combine = rbind,
.multicombine = T, .packages = c('foreach', 'doParallel')) %dopar% { # For each parents pair
#p = sire // m = dam
p <- sire[which(rownames(sire)==res[n,1]),, drop = F]
m <- dam[which(rownames(dam)==res[n,2]),, drop = F]
# Keep likelihood and missmatches
sc_exclu <- vector(mode = 'numeric', length = x.col)
sc_like <- vector(mode = 'numeric', length = x.col)
off_split <- strsplit(tmp, split = "/", fixed = T)
p_split <- strsplit(p, split = "/", fixed = T)
m_split <- strsplit(m, split = "/", fixed = T)
mrk <- 1
while (mrk <= x.col & sum(sc_exclu) <= thresh) { # For each marker
off_mrk <- off_split[[mrk]]
p_mrk <- p_split[[mrk]]
m_mrk <- m_split[[mrk]]
if (off_mrk[1]=='NA'&off_mrk[2]=='NA') { # if offspring genotype is missing
sc_exclu[mrk] <- 0
sc_like[mrk] <- 1
} else if (off_mrk[1]==off_mrk[2]&off_mrk[1]!='NA') { #If offspring is HOMOZYGOUS
# SIRE ID
if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
if (p_mrk[1]=='NA') {
p_id <- 4 # sire NA/NA
}else if (p_mrk[1]==off_mrk[1]) {
p_id <- 1 # sire A/A
} else {
p_id <- 3 # sire "C/C"
}
} else { # If the sire is HETEROZYGOUS
if ((p_mrk[1]!=off_mrk[1]&p_mrk[2]!=off_mrk[1])&(p_mrk[1]!=off_mrk[2]&p_mrk[2]!=off_mrk[2])) {
p_id <- 3 # sire C/C
} else {
p_id <- 2 # sire A/C
}
}
#DAM ID
if (m_mrk[1]==m_mrk[2]) { #If the dam is HOMOZYGOUS
if (m_mrk[1]=='NA') {
m_id <- 4 # dam NA/NA
}else if (m_mrk[1]==off_mrk[1]) {
m_id <- 1 # dam A/A
} else {
m_id <- 3 # dam C/C
}
} else { # If the dam is HETEROZYGOUS
if ((m_mrk[1]!=off_mrk[1]&m_mrk[2]!=off_mrk[1])&(m_mrk[1]!=off_mrk[2]&m_mrk[2]!=off_mrk[2])) {
m_id <- 3 # dam C/C
} else {
m_id <- 2 # dam A/C
}
}
sc_exclu[mrk] <- homo_exclu[m_id,p_id]
sc_like[mrk] <- table_like[[mrk]][m_id, p_id]
} else { #If the offspring is HETEROZYGOUS
# SIRE ID
if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
if (p_mrk[1]=='NA') {
p_id <- 7 # sire NA/NA
}else if (p_mrk[1]==off_mrk[1]) {
p_id <- 1 # sire A/A
} else if (p_mrk[1]==off_mrk[2]) {
p_id <- 3 # sire B/B
} else {
p_id <- 6 # sire C/C
}
} else { # If the sire is HETEROZYGOUS
if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
p_id <- 2 # sire A/B
} else if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]!=off_mrk[2]|p_mrk[2]!=off_mrk[2])){
p_id <- 4 # sire A/C
} else if ((p_mrk[1]!=off_mrk[1]|p_mrk[2]!=off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
p_id <- 5 # sire B/C
} else {
p_id <- 6 # sire C/C
}
}
# DAM ID
if (m_mrk[1]==m_mrk[2]) { # If the dam is HOMOZYGOUS
if (m_mrk[1]=='NA') {
m_id <- 7 # dam NA/NA
}else if (m_mrk[1]==off_mrk[1]) {
m_id <- 1 # dam A/A
} else if (m_mrk[1]==off_mrk[2]) {
m_id <- 3 # dam B/B
} else {
m_id <- 6 # dam C/C
}
} else { # If the dam is HETEROZYGOUS
if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
m_id <- 2 # dam A/B
} else if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]!=off_mrk[2]|m_mrk[2]!=off_mrk[2])){
m_id <- 4 # dam A/C
} else if ((m_mrk[1]!=off_mrk[1]|m_mrk[2]!=off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
m_id <- 5 # dam B/C
} else {
m_id <- 6 # dam C/C
}
}
# Get the score for tested marker
sc_exclu[mrk] <- hetero_exclu[m_id,p_id]
sc_like[mrk] <- table_like[[mrk]][m_id, p_id]
}
mrk <- mrk + 1
}
# Create the parallel loop output
r <- c(NA,NA)
r[1] <- sum(sc_exclu) # Number of missmatch
r[2] <- exp(sum(log(sc_like))/ped.log[off,2]) # Mendelian transimission probability
return(r)
}
# Working on the results
res[,2:4] <- t
res <- as.data.frame(res)
res$sire <- as.character(res$sire)
res$dam <- as.character(res$dam)
res$score_exclu <- as.numeric(as.character(res$score_exclu))
res$P_mendel <- as.numeric(as.character(res$P_mendel))
# Order by Mendelian transmission probabilities
res2 <- res[order(res[,4], res[,3], decreasing = T),]
delta_P12 <- res2[1,4]-res2[2,4]
delta_P23 <- res2[2,4]-res2[3,4]
p_fin <- res2[1,1]
m_fin <- res2[1,2]
ped.out <- c(rownames(tmp), NA, NA)
if (is.na(p_fin)&is.na(m_fin)) {
ped.out[2:3] <- c(NA, NA)
} else {
ped.out[2:3] <- c(p_fin,m_fin)
}
log.out <- unlist(c(ped.out[1], ped.log[off,2], ped.out[2:3], res2[1, 3:4],
res2[2,1:4], delta_P12,
res2[3,1:4], delta_P23))
# Order by mismatches
res2 <- res[order(res[,3], -res[,4], decreasing = F),]
exclu.out <- unlist(c(log.out[1],ped.log[off,2], res2[1,1:3], res2[2,1:3], res2[3,1:3]))
t
res
A <- foreach(off=1:iterations, .multicombine = T,
.packages = c('foreach', 'doParallel'), .options.snow = opts) %dopar% { # For each offspring
tmp <- offspring[off,, drop = F]
# Create temporary results
res <- matrix(NA, nrow = (nrow(sire)*nrow(dam)), ncol = 4)
colnames(res) <- c('sire', 'dam', 'score_exclu', 'P_mendel')
res[,1] <- rep(rownames(sire), each = nrow(dam))
res[,2] <- rep(rownames(dam), times = nrow(sire))
# Lielihood tables
table_like <- vector('list', x.col)
off_geno <- strsplit(tmp, split = "/", fixed = T)
for (i in 1:length(tmp)) {
if (off_geno[[i]][1]==off_geno[[i]][2]) {
fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
table_like[[i]] <- matrix(c(1,0.5,e,fa,0.5,0.25,e,0.5*fa,e,e,e,e,fa,0.5*fa,e,fa*fa), nrow = 4, ncol = 4)
} else {
fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
fb <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][2]))]
fb <- ifelse(test = (fb==0|is.na(fb)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fb)
table_like[[i]] <- matrix(c(e,0.5,1,e,0.5,e,fb,
0.5,0.5,0.5,0.25,0.5,e,0.5*(fa+fb),
1,0.5,e,0.5,e,e,fa,
e,0.25,0.5,e,0.25,e,0.5*fb,
0.5,0.25,e,0.25,e,e,0.5*fb,
e,e,e,e,e,e,e,
fb,0.5*(fa+fb),fa,0.5*fb,0.5*fa,e,2*fa*fb), nrow = 7, ncol = 7)
}
}
t <- foreach(n = 1:nrow(res), .combine = rbind,
.multicombine = T, .packages = c('foreach', 'doParallel')) %dopar% { # For each parents pair
#p = sire // m = dam
p <- sire[which(rownames(sire)==res[n,1]),, drop = F]
m <- dam[which(rownames(dam)==res[n,2]),, drop = F]
# Keep likelihood and missmatches
sc_exclu <- vector(mode = 'numeric', length = x.col)
sc_like <- vector(mode = 'numeric', length = x.col)
off_split <- strsplit(tmp, split = "/", fixed = T)
p_split <- strsplit(p, split = "/", fixed = T)
m_split <- strsplit(m, split = "/", fixed = T)
mrk <- 1
while (mrk <= x.col & sum(sc_exclu) <= thresh) { # For each marker
off_mrk <- off_split[[mrk]]
p_mrk <- p_split[[mrk]]
m_mrk <- m_split[[mrk]]
if (off_mrk[1]=='NA'&off_mrk[2]=='NA') { # if offspring genotype is missing
sc_exclu[mrk] <- 0
sc_like[mrk] <- 1
} else if (off_mrk[1]==off_mrk[2]&off_mrk[1]!='NA') { #If offspring is HOMOZYGOUS
# SIRE ID
if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
if (p_mrk[1]=='NA') {
p_id <- 4 # sire NA/NA
}else if (p_mrk[1]==off_mrk[1]) {
p_id <- 1 # sire A/A
} else {
p_id <- 3 # sire "C/C"
}
} else { # If the sire is HETEROZYGOUS
if ((p_mrk[1]!=off_mrk[1]&p_mrk[2]!=off_mrk[1])&(p_mrk[1]!=off_mrk[2]&p_mrk[2]!=off_mrk[2])) {
p_id <- 3 # sire C/C
} else {
p_id <- 2 # sire A/C
}
}
#DAM ID
if (m_mrk[1]==m_mrk[2]) { #If the dam is HOMOZYGOUS
if (m_mrk[1]=='NA') {
m_id <- 4 # dam NA/NA
}else if (m_mrk[1]==off_mrk[1]) {
m_id <- 1 # dam A/A
} else {
m_id <- 3 # dam C/C
}
} else { # If the dam is HETEROZYGOUS
if ((m_mrk[1]!=off_mrk[1]&m_mrk[2]!=off_mrk[1])&(m_mrk[1]!=off_mrk[2]&m_mrk[2]!=off_mrk[2])) {
m_id <- 3 # dam C/C
} else {
m_id <- 2 # dam A/C
}
}
sc_exclu[mrk] <- homo_exclu[m_id,p_id]
sc_like[mrk] <- table_like[[mrk]][m_id, p_id]
} else { #If the offspring is HETEROZYGOUS
# SIRE ID
if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
if (p_mrk[1]=='NA') {
p_id <- 7 # sire NA/NA
}else if (p_mrk[1]==off_mrk[1]) {
p_id <- 1 # sire A/A
} else if (p_mrk[1]==off_mrk[2]) {
p_id <- 3 # sire B/B
} else {
p_id <- 6 # sire C/C
}
} else { # If the sire is HETEROZYGOUS
if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
p_id <- 2 # sire A/B
} else if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]!=off_mrk[2]|p_mrk[2]!=off_mrk[2])){
p_id <- 4 # sire A/C
} else if ((p_mrk[1]!=off_mrk[1]|p_mrk[2]!=off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
p_id <- 5 # sire B/C
} else {
p_id <- 6 # sire C/C
}
}
# DAM ID
if (m_mrk[1]==m_mrk[2]) { # If the dam is HOMOZYGOUS
if (m_mrk[1]=='NA') {
m_id <- 7 # dam NA/NA
}else if (m_mrk[1]==off_mrk[1]) {
m_id <- 1 # dam A/A
} else if (m_mrk[1]==off_mrk[2]) {
m_id <- 3 # dam B/B
} else {
m_id <- 6 # dam C/C
}
} else { # If the dam is HETEROZYGOUS
if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
m_id <- 2 # dam A/B
} else if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]!=off_mrk[2]|m_mrk[2]!=off_mrk[2])){
m_id <- 4 # dam A/C
} else if ((m_mrk[1]!=off_mrk[1]|m_mrk[2]!=off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
m_id <- 5 # dam B/C
} else {
m_id <- 6 # dam C/C
}
}
# Get the score for tested marker
sc_exclu[mrk] <- hetero_exclu[m_id,p_id]
sc_like[mrk] <- table_like[[mrk]][m_id, p_id]
}
mrk <- mrk + 1
}
# Create the parallel loop output
r <- c(NA,NA)
r[1] <- sum(sc_exclu) # Number of missmatch
r[2] <- exp(sum(log(sc_like))/ped.log[off,2]) # Mendelian transimission probability
return(r)
}
# Working on the results
res[,3:4] <- t
res <- as.data.frame(res)
res$sire <- as.character(res$sire)
res$dam <- as.character(res$dam)
res$score_exclu <- as.numeric(as.character(res$score_exclu))
res$P_mendel <- as.numeric(as.character(res$P_mendel))
# Order by Mendelian transmission probabilities
res2 <- res[order(res[,4], res[,3], decreasing = T),]
delta_P12 <- res2[1,4]-res2[2,4]
delta_P23 <- res2[2,4]-res2[3,4]
p_fin <- res2[1,1]
m_fin <- res2[1,2]
ped.out <- c(rownames(tmp), NA, NA)
if (is.na(p_fin)&is.na(m_fin)) {
ped.out[2:3] <- c(NA, NA)
} else {
ped.out[2:3] <- c(p_fin,m_fin)
}
log.out <- unlist(c(ped.out[1], ped.log[off,2], ped.out[2:3], res2[1, 3:4],
res2[2,1:4], delta_P12,
res2[3,1:4], delta_P23))
# Order by mismatches
res2 <- res[order(res[,3], -res[,4], decreasing = F),]
exclu.out <- unlist(c(log.out[1],ped.log[off,2], res2[1,1:3], res2[2,1:3], res2[3,1:3]))
a <- list(ped.out, log.out, exclu.out)
}
close(pb)
stopCluster(cl)
ped <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[1]]}))))
colnames(ped) <- c('off', 'sire', 'dam')
rownames(ped) <- c(1:nrow(ped))
# Working on the data
ped$off <- as.character(ped$off)
ped$sire <- as.character(ped$sire)
ped$dam <- as.character(ped$dam)
ped
ped.log <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[2]]}))))
colnames(ped.log) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1', 'mendel1',
'sire2', 'dam2', 'miss2', 'mendel2', 'delta_Pmendel12',
'sire3', 'dam3', 'miss3', 'mendel3', 'delta_Pmendel23')
rownames(ped.log) <- c(1:nrow(ped.log))
ped.log[,] <- sapply(ped.log[,c(1:ncol(ped.log))], as.character)
ped.log[,c(2, 5:6, 9:11, 14:16)] <- sapply(ped.log[,c(2, 5:6, 9:11, 14:16)], as.numeric)
ped.exclu <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[3]]}))))
colnames(ped.exclu) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1',
'sire2', 'dam2', 'miss2',
'sire3', 'dam3', 'miss3')
rownames(ped.exclu) <- c(1:nrow(ped.exclu))
ped.exclu[,c(2,5,8,11)] <- sapply(ped.exclu[,c(2,5,8,11)], as.numeric)
error <- 0.01
# Create the pedigree output
ped <- as.data.frame(matrix(NA, ncol = 3, nrow = nrow(ped.log)))
colnames(ped) <- c('off', 'sire', 'dam')
ped[,1] <- ped.log[,1]
# Plot of Mendelian transmission probability distributions
mendel <- rep(NA, times = 2*nrow(ped.log))
mendel[seq(1, length(mendel), 2)] <- ped.log$mendel1
mendel[seq(2, length(mendel), 2)] <- ped.log$mendel2
data.mendel <- data.frame(mendel = mendel,
P = rep(c("P1", "P2"), times = nrow(ped.log)))
delta <- rep(NA, times = 2*nrow(ped.log))
delta[seq(1, length(delta), 2)] <- ped.log$delta_Pmendel12
delta[seq(2, length(delta), 2)] <- ped.log$delta_Pmendel23
data.delta <- data.frame(delta = delta,
P = rep(c("delta1", "delta2"), times = nrow(ped.log)))
miss <- rep(NA, times = 2*nrow(ped.log))
miss[seq(1, length(miss), 2)] <- ped.log$miss1
miss[seq(2, length(miss), 2)] <- ped.log$miss2
data.miss <- data.frame(miss = miss,
P = rep(c("miss1", "miss2"), times = nrow(ped.log)))
if (is.null(error)) {
error <- as.numeric(readline(prompt = 'What assignment error rate do you accept : '))
} else {
}
# Calculate the median of P2m(:)
med_0 <- median(ped.log$mendel2)
mendel2_o <- sort(ped.log$mendel2)
mendel1_o <- sort(ped.log$mendel1)
N1_0 <- length(ped.log$mendel1[which(ped.log$mendel1<=med_0)])
N0 <- length(ped.log$mendel1)
while(TRUE) {
seuil <- min(ped.log$mendel2)
N2_l <- round(length(ped.log$mendel2[which(ped.log$mendel2<=seuil)]) -
(length(ped.log$mendel3[which(ped.log$mendel3<=seuil)]) * ((2*N1_0)/N0)))
vu <- c()
cpt <- 1
while(N2_l<((N0-(2*N1_0))/2) & cpt<=nrow(ped.log)) {
seuil <- mendel2_o[cpt]
N2_l <- round(length(ped.log$mendel2[which(ped.log$mendel2<=seuil)]) -
(length(ped.log$mendel3[which(ped.log$mendel3<=seuil)]) * ((2*N1_0)/N0)))
cpt <- cpt+1
}
med_1 <- seuil
N1_0 <- length(ped.log$mendel1[which(ped.log$mendel1<=med_0)])
N1_1 <- length(ped.log$mendel1[which(ped.log$mendel1<=med_1)])
diffN <- N1_1 - N1_0
if (diffN<=1) {
break
} else {
med_0 <- med_1
}
}
N1_1min <- length(which(ped.log$mendel1<=median(ped.log$mendel2)))
N1_1 <- ifelse(test = N1_1>round(nrow(ped.log)/2), yes = round(nrow(ped.log)/2), no = N1_1)
cat('Estimated number of offspring with at least one missing parent : between',2*N1_1min,'and',2*N1_1)
cat('\n')
#####-----------------------------------------------------
##### THRESHOLD
#####-----------------------------------------------------
# If the number of offspring with at least one missing parent is LOWER than the user-defined error
if ((2*N1_1)<=round(error*nrow(ped.log))) {
cat('--------------------------------------', sep = '\n')
cat('     BEST MENDELIAN PROBABILITY', sep = '\n')
cat('--------------------------------------', sep = '\n')
ped[,2:3] <- ped.log[,3:4]
ped$assign <- 'assign'
thresh.mendel <- min(ped.log$delta_Pmendel12)
} else {
# If the number of offspring with at least one missing parent is GREATER than the user-defined error
cat('--------------------------------------', sep = '\n')
cat('    DELTA OF MENDELIAN PROBABILITY', sep = '\n')
cat('--------------------------------------', sep = '\n')
s.delta23 <- sort(ped.log$delta_Pmendel23, decreasing = T)
thresh.mendel <- quantile(s.delta23[1:(nrow(ped.log) - 2*N1_1min)], probs = (1-error), type = 5, na.rm = T)
cat('Threshold for delta :', thresh.mendel)
cat('\n')
ped[,2:3] <- ped.log[,c(3:4)]
ped$assign <- ifelse(test = ped.log$delta_Pmendel12 >= thresh.mendel, yes = 'assign', no = 'no.assign')
}
# Reformate outputs
ped.final <- ped
ped.final[which(ped.final$assign == 'no.assign'), 2:3] <- c(NA, NA)
# Plot the distributions
plot_mendel <- ggplot(data = data.mendel, aes(x = mendel, fill = P)) +
geom_histogram(data = subset(data.mendel, P == 'P2'), bins = 30) +
geom_histogram(data = subset(data.mendel, P == 'P1'), alpha = 0.8, bins = 30) +
xlab(label = "average Mendelian tranmission probability") +
ylab(label = "number of individuals") +
theme(axis.title.x = element_text(margin = margin(20, 0, 0, 0))) +
theme(axis.title.y = element_text(margin = margin(0, 20, 0, 0))) +
guides(fill = guide_legend(title = "Mendelian probability"))
plot_delta <- ggplot(data = data.delta, aes(x = delta, fill = P)) +
geom_histogram(data = subset(data.delta, P == 'delta2'), bins = 30) +
geom_histogram(data = subset(data.delta, P == 'delta1'), alpha = 0.8, bins = 30) +
geom_vline(xintercept = thresh.mendel) +
xlab(label = "delta") +
ylab(label = "number of individuals") +
theme(axis.title.x = element_text(margin = margin(20, 0, 0, 0))) +
theme(axis.title.y = element_text(margin = margin(0, 20, 0, 0))) +
guides(fill = guide_legend(title = "Delta"))
plot_miss <- ggplot(data = data.miss, aes(x = miss, fill = P)) +
geom_histogram(data = subset(data.miss, P == 'miss2'), bins = 30) +
geom_histogram(data = subset(data.miss, P == 'miss1'), alpha = 0.8, bins = 30) +
xlab(label = "number of mismatches") +
ylab(label = "number of individuals") +
theme(axis.title.x = element_text(margin = margin(20, 0, 0, 0))) +
theme(axis.title.y = element_text(margin = margin(0, 20, 0, 0))) +
guides(fill = guide_legend(title = "missmatches"))
grid.arrange(plot_mendel, plot_delta, plot_miss, nrow = 3, ncol = 1)
ped.final
ped.final <- ped.final[,-4]
ped.final
ped.log
library(APIS)
result <- APIS(off.genotype = off.genotype,
dam.genotype = dam.genotype,
sire.genotype = sire.genotype[sample(c(1:nrow(sire.genotype)),5),],
error = 0.05)
library(APIS)
result <- APIS(off.genotype = off.genotype,
dam.genotype = dam.genotype,
sire.genotype = sire.genotype[sample(c(1:nrow(sire.genotype)),5),],
error = 0.05)
library(APIS)
result <- APIS(off.genotype = off.genotype,
dam.genotype = dam.genotype,
sire.genotype = sire.genotype,
error = 0.05)
new.result <- personalThreshold(result, method = 'exclusion', threshold = 5)
install.packages("Rccp")
library(Rcpp)
install.packages(c("ade4", "breedR", "caTools", "curl", "data.table", "dotCall64", "dplyr", "evaluate", "gtools", "highr", "hsphase", "htmlwidgets", "httpuv", "knitr", "later", "lme4", "manipulateWidget", "markdown", "mclust", "microbenchmark", "mime", "modeest", "modeltools", "openssl", "plotmo", "plotrix", "qtl", "rcmdcheck", "RcppArmadillo", "RcppEigen", "RCurl", "reshape", "scrm", "shiny", "sp", "spam", "xtable", "yaml"))
install.packages(c("broom", "car", "carData", "caret", "class", "cli", "codetools", "colorspace", "data.table", "ddalpha", "digest", "dimRed", "doParallel", "dplyr", "e1071", "foreign", "ggplot2", "glue", "haven", "ipred", "kernlab", "lattice", "lava", "lme4", "magic", "maptools", "MASS", "Matrix", "mgcv", "ModelMetrics", "munsell", "nloptr", "pillar", "pkgconfig", "psych", "purrr", "quantreg", "R6", "RcppRoll", "readr", "readxl", "recipes", "rio", "rlang", "robustbase", "scales", "sfsmisc", "stringi", "stringr", "survival", "tibble", "tidyr", "tidyselect", "tkrplot"), lib="C:/Program Files/R/R-3.4.1/library")
install.packages(c("ade4", "breedR", "caTools", "curl", "data.table", "dotCall64", "dplyr", "evaluate", "gtools", "highr", "hsphase", "htmlwidgets", "httpuv", "knitr", "later", "lme4", "manipulateWidget", "markdown", "mclust", "microbenchmark", "mime", "modeest", "modeltools", "openssl", "plotmo", "plotrix", "qtl", "rcmdcheck", "RcppArmadillo", "RcppEigen", "RCurl", "reshape", "scrm", "shiny", "sp", "spam", "xtable", "yaml"))
unlink('vignettes/apis_vignette_cache', recursive = TRUE)
