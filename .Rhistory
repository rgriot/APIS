probability_table[[m]] <- c(0, 0, 1, NA)
} else {
probability_table[[m]] <- c(0, 0, 0, 0, 0, 1, NA)
}
}
# Loop over all the parents
for (p in output$parent) {
p.geno <- parent.genotype[which(rownames(parent.genotype) %in% p),]
p.geno <- strsplit(p.geno, split = '/')
# Probability
parent_probability <- rep(NA, length(p.geno))
# Loop over all the markers
for (m in c(1:length(off.genotype))) {
off.mrk <- off.geno[[m]]
p.mrk <- p.geno[[m]]
if (off.mrk[1] == off.mrk[2] & off.mrk[1] == 'NA') { # If offspring is NA/NA
parent_probability[m] <- 1
} else if (off.mrk[1] == off.mrk[2] & off.mrk[1] != 'NA') { # If offspring is homozygous
# Check parent genotype
if (p.mrk[1] == p.mrk[2] & p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][4]
} else if (p.mrk[1] == p.mrk[2] & p.mrk[1] != 'NA') {
if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][3]
}
} else { # parent heterozygous
if ((p.mrk[1] != off.mrk[1] & p.mrk[2] != off.mrk[1]) & (p.mrk[1] != off.mrk[2] & p.mrk[2] != off.mrk[2])) {
parent_probability[m] <- probability_table[[m]][3]
} else {
parent_probability[m] <- probability_table[[m]][2]
}
}
} else { # If offspring is heterozygous
if (p.mrk[1] == p.mrk[2]) { # parent homzygous
if (p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][7]
} else if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else if (p.mrk[1] == off.mrk[2]) { # parent B/B
parent_probability[m] <- probability_table[[m]][3]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
} else { # parent heterozygous
if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent A/B
parent_probability[m] <- probability_table[[m]][2]
} else if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] != off.mrk[2] | p.mrk[2] != off.mrk[2])) {
# parent A/C
parent_probability[m] <- probability_table[[m]][4]
} else if ((p.mrk[1] != off.mrk[1] | p.mrk[2] != off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent B/C
parent_probability[m] <- probability_table[[m]][5]
} else {
# parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
}
}
}
# Calculte the average probability for the parent
# Write the result
output[i, 3] <- sum(parent_probability, na.rm = T)
i <- i + 1
}
output <- output[order(output$mismatch),]
sire_toKeep <- output[which(output$sex == 'M'), ]
s.keep <- sire_toKeep[which(sire_toKeep$mismatch >= min(output$mismatch) &  sire_toKeep$mismatch <= (min(output$mismatch) + 2)),]
select.sire <- ifelse(test = parent_toKeep > nrow(sire_toKeep), yes = nrow(sire_toKeep), no = parent_toKeep)
if (nrow(s.keep) < parent_toKeep) {
s.keep <- rbind(s.keep, sire_toKeep[c((nrow(s.keep) + 1):select.sire),])
} else {
s.keep <- s.keep
}
sire_toKeep <- s.keep$parent
dam_toKeep <- output[which(output$sex == 'F'), ]
d.keep <- dam_toKeep[which(dam_toKeep$mismatch >= min(output$mismatch) & dam_toKeep$mismatch <= (min(output$mismatch) + 2)),]
select.dam <- ifelse(test = parent_toKeep > nrow(dam_toKeep), yes = nrow(dam_toKeep), no = parent_toKeep)
if (nrow(d.keep) < parent_toKeep) {
d.keep <- rbind(d.keep, dam_toKeep[c((nrow(d.keep) + 1):select.dam),])
} else {
d.keep <- d.keep
}
dam_toKeep <- d.keep$parent
# Return the most likely parents
return(list(sire_toKeep = sire_toKeep, dam_toKeep = dam_toKeep))
}
# Initialize the variables
parent_toKeep <- 5
i <- 1
output <- data.frame(parent = rownames(parent.genotype),
sex = parent.sex,
mismatch = NA)
output$parent <- as.character(output$parent)
# Create the probability tables
off.geno <- strsplit(off.genotype, split = '/')
probability_table <- vector('list', length(off.genotype))
for (m in c(1:length(off.genotype))) {
# If the offspring is homozygous
if (off.geno[[m]][1] == off.geno[[m]][2]) {
probability_table[[m]] <- c(0, 0, 1, NA)
} else {
probability_table[[m]] <- c(0, 0, 0, 0, 0, 1, NA)
}
}
for (p in output$parent) {
p.geno <- parent.genotype[which(rownames(parent.genotype) %in% p),]
p.geno <- strsplit(p.geno, split = '/')
# Probability
parent_probability <- rep(NA, length(p.geno))
# Loop over all the markers
for (m in c(1:length(off.genotype))) {
off.mrk <- off.geno[[m]]
p.mrk <- p.geno[[m]]
if (off.mrk[1] == off.mrk[2] & off.mrk[1] == 'NA') { # If offspring is NA/NA
parent_probability[m] <- 1
} else if (off.mrk[1] == off.mrk[2] & off.mrk[1] != 'NA') { # If offspring is homozygous
# Check parent genotype
if (p.mrk[1] == p.mrk[2] & p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][4]
} else if (p.mrk[1] == p.mrk[2] & p.mrk[1] != 'NA') {
if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][3]
}
} else { # parent heterozygous
if ((p.mrk[1] != off.mrk[1] & p.mrk[2] != off.mrk[1]) & (p.mrk[1] != off.mrk[2] & p.mrk[2] != off.mrk[2])) {
parent_probability[m] <- probability_table[[m]][3]
} else {
parent_probability[m] <- probability_table[[m]][2]
}
}
} else { # If offspring is heterozygous
if (p.mrk[1] == p.mrk[2]) { # parent homzygous
if (p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][7]
} else if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else if (p.mrk[1] == off.mrk[2]) { # parent B/B
parent_probability[m] <- probability_table[[m]][3]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
} else { # parent heterozygous
if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent A/B
parent_probability[m] <- probability_table[[m]][2]
} else if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] != off.mrk[2] | p.mrk[2] != off.mrk[2])) {
# parent A/C
parent_probability[m] <- probability_table[[m]][4]
} else if ((p.mrk[1] != off.mrk[1] | p.mrk[2] != off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent B/C
parent_probability[m] <- probability_table[[m]][5]
} else {
# parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
}
}
}
# Calculte the average probability for the parent
# Write the result
output[i, 3] <- sum(parent_probability, na.rm = T)
i <- i + 1
}
View(output)
log[which(log$off == "1000"),]
log2[which(log2$off == "1000"),]
tmp <- rbind(sire.geno[which(rownames(sire.geno) == "192"),], sire.geno[which(rownames(sire.geno) == "226"),], sire.geno[which(rownames(sire.geno) == "173"),])
tmp <- rbind(sire.geno[which(rownames(sire.geno) == "192"),], sire.geno[which(rownames(sire.geno) == "226"),], sire.geno[which(rownames(sire.geno) == "173"),], sire.geno[which(rownames(sire.geno) == "281"),], sire.geno[which(rownames(sire.geno) == "290"),])
View(tmp)
table(tmp[5,])
table(tmp[4,])
table(tmp[3,])
table(tmp[2,])
table(tmp[1,])
l.homo <- apply(parent.genotype, 1, function(X) {length(X[X[1] == X[2]])})
l.homo
l.homo <- apply(parent.genotype, 1, function(X) {length(X[which(X[1] == X[2])])})
l.homo
function(X) {
X.tmp <- strsplit(X, '/')
return(length(X[which(X.tmp[1] == X.tmp[2])]))
}
countHomo <- function(X) {
X.tmp <- strsplit(X, '/')
return(length(X[which(X.tmp[1] == X.tmp[2])]))
}
l.homo <- apply(parent.genotype, 1, countHomo)
countHomo <- function(X) {
X.tmp <- strsplit(X, '/')
return(length(X[which(X.tmp[[1]] == X.tmp[[2]])]))
}
l.homo <- apply(parent.genotype, 1, countHomo)
l.homo
l.homo <- apply(parent.genotype, 1, table)
l.homo <- as.numeric(apply(parent.genotype, 1, function(X) {length(X[X=='A/A'|X=='B/B'])}))
l.homo
output$mismatch / l.homo
output$mismatch <- output$mismatch / l.homo
View(output)
hist(output$mismatch)
hist(output$mismatch, breaks = 20)
# Initialize the variables
parent_toKeep <- 5
i <- 1
output <- data.frame(parent = rownames(parent.genotype),
sex = parent.sex,
mismatch = NA)
output$parent <- as.character(output$parent)
# Create the probability tables
off.geno <- strsplit(off.genotype, split = '/')
probability_table <- vector('list', length(off.genotype))
for (m in c(1:length(off.genotype))) {
# If the offspring is homozygous
if (off.geno[[m]][1] == off.geno[[m]][2]) {
probability_table[[m]] <- c(0, 0, 1, NA)
} else {
probability_table[[m]] <- c(0, 0, 0, 0, 0, 1, NA)
}
}
# Loop over all the parents
for (p in output$parent) {
p.geno <- parent.genotype[which(rownames(parent.genotype) %in% p),]
p.geno <- strsplit(p.geno, split = '/')
# Probability
parent_probability <- rep(NA, length(p.geno))
# Loop over all the markers
for (m in c(1:length(off.genotype))) {
off.mrk <- off.geno[[m]]
p.mrk <- p.geno[[m]]
if (off.mrk[1] == off.mrk[2] & off.mrk[1] == 'NA') { # If offspring is NA/NA
parent_probability[m] <- 1
} else if (off.mrk[1] == off.mrk[2] & off.mrk[1] != 'NA') { # If offspring is homozygous
# Check parent genotype
if (p.mrk[1] == p.mrk[2] & p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][4]
} else if (p.mrk[1] == p.mrk[2] & p.mrk[1] != 'NA') {
if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][3]
}
} else { # parent heterozygous
if ((p.mrk[1] != off.mrk[1] & p.mrk[2] != off.mrk[1]) & (p.mrk[1] != off.mrk[2] & p.mrk[2] != off.mrk[2])) {
parent_probability[m] <- probability_table[[m]][3]
} else {
parent_probability[m] <- probability_table[[m]][2]
}
}
} else { # If offspring is heterozygous
if (p.mrk[1] == p.mrk[2]) { # parent homzygous
if (p.mrk[1] == 'NA') { # parent NA/NA
parent_probability[m] <- probability_table[[m]][7]
} else if (p.mrk[1] == off.mrk[1]) { # parent A/A
parent_probability[m] <- probability_table[[m]][1]
} else if (p.mrk[1] == off.mrk[2]) { # parent B/B
parent_probability[m] <- probability_table[[m]][3]
} else { # parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
} else { # parent heterozygous
if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent A/B
parent_probability[m] <- probability_table[[m]][2]
} else if ((p.mrk[1] == off.mrk[1] | p.mrk[2] == off.mrk[1]) & (p.mrk[1] != off.mrk[2] | p.mrk[2] != off.mrk[2])) {
# parent A/C
parent_probability[m] <- probability_table[[m]][4]
} else if ((p.mrk[1] != off.mrk[1] | p.mrk[2] != off.mrk[1]) & (p.mrk[1] == off.mrk[2] | p.mrk[2] == off.mrk[2])) {
# parent B/C
parent_probability[m] <- probability_table[[m]][5]
} else {
# parent C/C
parent_probability[m] <- probability_table[[m]][6]
}
}
}
}
# Calculte the average probability for the parent
# Write the result
output[i, 3] <- sum(parent_probability, na.rm = T)
i <- i + 1
}
View(output)
library(APIS)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05)
sire.geno <- geno[which(rownames(geno) %in% c(151:300)),]
dam.geno <- geno[which(rownames(geno) %in% c(1:150)),]
off.geno <- geno[which(rownames(geno) %in% c(301:1000)),]
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05)
library(APIS)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05)
library(APIS)
sire.geno <- geno[which(rownames(geno) %in% c(151:300)),]
dam.geno <- geno[which(rownames(geno) %in% c(1:150)),]
off.geno <- geno[which(rownames(geno) %in% c(301:1000)),]
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05,
preselect.Parent = 5)
library(APIS)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05,
preselect.Parent = 5)
library(APIS)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05,
preselect.Parent = 5)
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05,
preselect.Parent = c(5,10))
result <- APIS(off.genotype = off.geno,
sire.genotype = sire.geno,
dam.genotype = dam.geno,
error = 0.05,
preselect.Parent = F)
setwd("D:/Data_RG/package_APIS/APIS")
library(APIS)
knit_with_parameters('D:/Data_RG/package_APIS/APIS/vignettes/apis_vignette.Rmd', encoding = 'UTF-8')
install.packages("float")
library(float)
library(APIS)
dir()
library(APIS)
data("genotype_APIS")
l <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
rm(list = ls())
setwd("D:/Data_RG/Migado")
off.ped <- as.matrix(read.table('off.txt'))
off.ped <- as.matrix(read.table('off.txt', header = T))
View(off.ped)
off.ped <- as.matrix(read.table('off.txt'))
View(off.ped)
off.ped <- as.matrix(read.table('off.txt', row.names = 1))
sire.ped <- as.matrix(read.table('sire.txt', row.names = 1))
dam.ped <- as.matrix(read.table('dam.txt', row.names = 1))
apis <- APIS(off.genotype = off.ped,
sire.genotype = sire.ped,
dam.genotype = dam.ped,
error = 0.05)
off.genotype = off.ped
sire.genotype = sire.ped
dam.genotype = dam.ped
error = 0.05
# Check inputs
#	Check if all genotypes matrices have the same number of markers
if (ncol(off.genotype) == ncol(sire.genotype) & ncol(off.genotype) == ncol(dam.genotype) & ncol(sire.genotype) == ncol(dam.genotype)) {
cat("genotype matrices : OK")
cat('\n')
} else {
stop("Your genotype matrices do not have the same number of markers")
}
#	Check if the number of mismatches allowed is lower than the number of markers and positive
if ((0 <= exclusion.threshold) && (exclusion.threshold <= ncol(off.genotype))) {
cat("exclusion threshold : OK")
cat('\n')
} else {
stop("The exclusion threshold is greater than the number of markers")
}
# Check if the user-defined assignment error rate limit is a percentage
if ((0 <= error) && (error <= 100)) {
cat("assignment error rate : OK")
cat('\n')
} else {
stop("The assignment error rate limit is NEGATIVE")
}
# Calculate the theoretical assignment power
P <- assignmentPower(sire = sire.genotype, dam = dam.genotype)
P2 <- substr(as.character(100 * P), 1, 6)
cat("The assignment power of your marker set is ", P2, "%", sep = "")
cat('\n')
if (P >= 0.99) {
cat("Theoretical assignment power : OK")
cat('\n')
} else {
message("WARNING! Your marker set is not enough powerfull!")
}
offspring = off.genotype
sire = sire.genotype
dam = dam.genotype
thresh = exclusion.threshold
exclusion.threshold = ncol(off.genotype)
thresh = exclusion.threshold
# DESCRIPTION
# Function to calculate average Mendelian transmission probabilities
# Stop if different number of markers are provided
if (ncol(offspring)!=ncol(sire)&ncol(offspring)!=ncol(dam))
stop('Genotypes must have the same number of markers')
# Create the results matrix
ped.log <- as.data.frame(matrix(NA,nrow = nrow(offspring), ncol = 16))
colnames(ped.log) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1', 'mendel1',
'sire2', 'dam2', 'miss2', 'mendel2', 'delta_Pmendel12',
'sire3', 'dam3', 'miss3', 'mendel3', 'delta_Pmendel23')
ped.log[,1] <- rownames(offspring)
ped.log[,2] <- as.numeric(apply(offspring,1, function(X) {length(X[X!='NA/NA'])}))
ped.exclu <- as.data.frame(matrix(NA, nrow = nrow(offspring), ncol = 11))
colnames(ped.exclu) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1',
'sire2', 'dam2', 'miss2',
'sire3', 'dam3', 'miss3')
# Parameters
e <- 0.01 # Genotyping error of 1%
# Estimate allele frequencies
cat('Estimation of allele frequencies')
cat('\n')
Freq <- allFreq(offspring)
x.col <- ncol(offspring)
iterations <- nrow(offspring)
cat('Recoding datasets')
cat('\n')
# Recode for Fortran subroutine
recodeFortran <- function(mrk, list.mrk) {
tmp <- unlist(strsplit(mrk, '/'))
all1 <- list.mrk[which(list.mrk[,1] == tmp[1]),2]
all2 <- list.mrk[which(list.mrk[,1] == tmp[2]),2]
return(c(all1, all2))
}
recodeFreq <- function(name.col, list.mrk) {
tmp <- unlist(strsplit(name.col, '_'))[2]
return(list.mrk[which(list.mrk[,1] == tmp), 2])
}
variant <- unique(unlist(strsplit(as.vector(offspring), '/')))
variant <- variant[-which(variant == "NA")]
variant.corres <- data.frame(variant = as.character(variant),
recode = c(1:length(variant)))
variant.corres$variant <- as.character(variant.corres$variant)
variant.corres <- rbind(variant.corres, c(as.character("NA"), 0))
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
recode.off <- foreach(i = 1:iterations, .combine = rbind) %dopar% {
tmp <- as.numeric(as.vector(sapply(offspring[i,, drop = F], recodeFortran, list.mrk = variant.corres)))
}
recode.sire <- foreach(i = 1:nrow(sire), .combine = rbind) %dopar% {
tmp <- as.numeric(as.vector(sapply(sire[i,, drop = F], recodeFortran, list.mrk = variant.corres)))
}
recode.dam <- foreach(i = 1:nrow(dam), .combine = rbind) %dopar% {
tmp <- as.numeric(as.vector(sapply(dam[i,, drop = F], recodeFortran, list.mrk = variant.corres)))
}
stopCluster(cl)
rownames(recode.off) <- rownames(offspring)
rownames(recode.sire) <- rownames(sire)
rownames(recode.dam) <- rownames(dam)
Freq <- Freq[,-which(colnames(Freq) == "Freq_NA")]
Freq <- Freq[, c((floor(ncol(Freq)/2)+2):ncol(Freq))]
colnames(Freq) <- sapply(colnames(Freq), recodeFreq, list.mrk = variant.corres)
Freq <- rbind(colnames(Freq), Freq)
Freq <- apply(Freq, 2, as.numeric)
Freq <- Freq[,order(Freq[1,])]
Freq <- Freq[-1,]
recodeFortran <- function(mrk, list.mrk) {
tmp <- unlist(strsplit(mrk, '/'))
all1 <- list.mrk[which(list.mrk[,1] == tmp[1]),2]
all2 <- list.mrk[which(list.mrk[,1] == tmp[2]),2]
return(c(all1, all2))
}
recodeFreq <- function(name.col, list.mrk) {
tmp <- unlist(strsplit(name.col, '_'))[2]
return(list.mrk[which(list.mrk[,1] == tmp), 2])
}
variant <- unique(unlist(strsplit(as.vector(offspring), '/')))
variant <- variant[-which(variant == "NA")]
variant.corres <- data.frame(variant = as.character(variant),
recode = c(1:length(variant)))
variant.corres$variant <- as.character(variant.corres$variant)
variant.corres <- rbind(variant.corres, c(as.character("NA"), 0))
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
recode.off <- foreach(i = 1:iterations, .combine = rbind) %dopar% {
tmp <- as.numeric(as.vector(sapply(offspring[i,, drop = F], recodeFortran, list.mrk = variant.corres)))
}
View(recode.off)
recode.sire <- foreach(i = 1:nrow(sire), .combine = rbind) %dopar% {
tmp <- as.numeric(as.vector(sapply(sire[i,, drop = F], recodeFortran, list.mrk = variant.corres)))
}
View(sire)
variant.corres
i <- 98
stopCluster(cl)
sire[i,, drop = F]
variant.corres
sire[i,, drop = F]
sapply(sire[i,, drop = F], recodeFortran, list.mrk = variant.corres)
devtools::install_github('rgriot/APIS')
R.Version()
library(Rtools)
devtools::install_github('rgriot/APIS')
devtools::install_github('rgriot/APIS', force = T)
