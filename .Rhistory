rownames(female.genotype) <- female.genotype[,1] ; female.genotype <- female.genotype[,-1]
new.offspring <- matrix(NA, nrow = nrow(offspring.genotype), ncol = 1000)
new.male <- matrix(NA, nrow = nrow(male.genotype), ncol = 1000)
new.female <- matrix(NA, nrow = nrow(female.genotype), ncol = 1000)
mrk <- seq(1, 2000, 2)
recodeAPIS <- function(X) {
if (X[1] == 1 & X[2] == 1) {
return("A/A")
} else if ((X[1] == 1 & X[2] == 2) | (X[2] == 1 & X[1] == 2)) {
return("A/B")
} else if (X[1] == 2 & X[2] == 2) {
return("B/B")
} else {
return("NA/NA")
}
}
j <- 1
for (i in mrk) {
col.select <- c(i, i + 1)
# offsrping
tmp.offspring <- offspring.genotype[,col.select]
recode.offspring <- apply(tmp.offspring, 1, recodeAPIS)
new.offspring[,j] <- recode.offspring
# sire
tmp.sire <- male.genotype[,col.select]
recode.sire <- apply(tmp.sire, 1, recodeAPIS)
new.male[,j] <- recode.sire
# dam
tmp.dam <- female.genotype[,col.select]
recode.female <- apply(tmp.dam, 1, recodeAPIS)
new.female[,j] <- recode.female
j <- j + 1
}
# Sire matrix
new.sire <- rbind(new.male, sire.matrix[which(rownames(sire.matrix) == "*6"),], dam.matrix)
rownames(new.sire) <- c(rownames(male.genotype), "*6", rownames(dam.matrix))
new.dam <- rbind(new.female, sire.matrix[which(rownames(sire.matrix) != "*6"),])
rownames(new.dam)[1:15] <- rownames(female.genotype)
rownames(new.offspring) <- rownames(offspring.genotype)
colnames(new.sire)
colnames(new.dam)
colnames(new.offspring) <- colnames(new.sire)
new.offspring <- as.matrix(new.offspring)
new.sire <- as.matrix(new.sire)
new.dam <- as.matrix(new.dam)
table(new.offspring)
table(new.sire)
table(new.dam)
str(new.offspring)
str(new.sire)
str(new.dam)
dim(new.offspring)
dim(new.sire)
dim(new.dam)
off.genotype = new.offspring
sire.genotype = new.sire
dam.genotype = new.dam
error = 0.05
exclusion.threshold = ncol(off.genotype)
preselect.Parent = F
#	Check if all genotypes matrices have the same number of markers
if (ncol(off.genotype) == ncol(sire.genotype) & ncol(off.genotype) == ncol(dam.genotype) & ncol(sire.genotype) == ncol(dam.genotype)) {
cat("genotype matrices : OK")
cat('\n')
} else {
stop("Your genotype matrices do not have the same number of markers")
}
#	Check if the number of mismatches allowed is lower than the number of markers and positive
if ((0 <= exclusion.threshold) && (exclusion.threshold <= ncol(off.genotype))) {
cat("exclusion threshold : OK")
cat('\n')
} else {
stop("The exclusion threshold is greater than the number of markers")
}
# Check if the user-defined assignment error rate limit is a percentage
if ((0 <= error) && (error <= 100)) {
cat("assignment error rate : OK")
cat('\n')
} else {
stop("The assignment error rate limit is NEGATIVE")
}
# Calculate the theoretical assignment power
P <- assignmentPower(sire = sire.genotype, dam = dam.genotype)
allFreq <- function(genotype) {
# DESCRIPTION
# Estimate allele frequencies based on genotype matrix
# Create the genotype matrix for new coding genotypes (2 columns)
mat.geno <- matrix(NA, nrow = nrow(genotype), ncol = 2*ncol(genotype))
imp <- seq(1,ncol(mat.geno),2)
# Divide each genotype (coded A/A) into 2 columns
for (i in c(1:ncol(genotype))) {
tmp <- strsplit(genotype[,i], split = '/', fixed = T)
M <- t(mapply(FUN = function(X) {X}, tmp))
mat.geno[,(imp[i]:(imp[i]+1))] <- M
}
# List of the different alleles
variant <- sort(unique(unlist(as.list(apply(mat.geno,2,unique)))))
# Create the results matrix
mat.res <- matrix(0, nrow = ncol(genotype), ncol = length(variant))
rownames(mat.res) <- colnames(genotype)
colnames(mat.res) <- variant
for (n in 1:nrow(mat.res)) {
tmp <- table(mat.geno[,(imp[n]:(imp[n]+1))])
mat.res[n,match(names(tmp), colnames(mat.res))] <- tmp
}
# Calculte the allele frequencies
mat.freq <- mat.res/(rowSums(mat.res[,which(colnames(mat.res)!='NA')]))
colnames(mat.freq) <- paste0('Freq_',colnames(mat.res))
# Merge the results
res <- cbind(mat.res, tot = rowSums(mat.res), mat.freq)
# Return the result
return(res)
}
assignmentPower <- function(sire, dam) {
# DESCRIPTION
# This function calculates the theoretical assignment power as proposed in Vandeputte, M (2012)
pop <- rbind(sire, dam)
# Importe the allFreq function and calculate the allele frequencies
freq <- allFreq(as.matrix(pop))
col <- which(colnames(freq)=='tot')
freq.calc <- as.data.frame(freq[,((col+1):ncol(freq))])
test.NA <- which(colnames(freq.calc) == "Freq_NA")
if (length(test.NA) != 0) {
freq.calc <- freq.calc[,-test.NA]
}
mcol <- ncol(freq.calc)
# Calculate Q1 and Q3 for each marker
freq.calc$Q1i <- 1 - 2*rowSums(freq.calc[,1:mcol]^2) +
rowSums(freq.calc[,1:mcol]^3) + 2*rowSums(freq.calc[,1:mcol]^4) -
2*rowSums(freq.calc[,1:mcol]^2)^2 - 3*rowSums(freq.calc[,1:mcol]^5) +
3*rowSums(freq.calc[,1:mcol]^3)*rowSums(freq.calc[,1:mcol]^2)
freq.calc$Q3i <- 1 + 4*rowSums(freq.calc[,1:mcol]^4) -
4*rowSums(freq.calc[,1:mcol]^5) - 3*rowSums(freq.calc[,1:mcol]^6) -
8*rowSums(freq.calc[,1:mcol]^2)^2 + 2*rowSums(freq.calc[,1:mcol]^3)^2 +
8*rowSums(freq.calc[,1:mcol]^3)*rowSums(freq.calc[,1:mcol]^2)
# Calculate the global Q1 and Q3
Q1 <- 1 - prod(1-freq.calc$Q1i)
Q3 <- 1 - prod(1-freq.calc$Q3i)
# Calculate the assignment power
Pu <- Q1^(nrow(dam)+nrow(sire)-2)*Q3^((nrow(dam)-1)*(nrow(sire)-1))
# Return the result
return(Pu)
}
# Calculate the theoretical assignment power
P <- assignmentPower(sire = sire.genotype, dam = dam.genotype)
sire = sire.genotype
dam = dam.genotype
pop <- rbind(sire, dam)
# Importe the allFreq function and calculate the allele frequencies
freq <- allFreq(as.matrix(pop))
pop <- as.matrix(pop)
genotype <- pop
# Create the genotype matrix for new coding genotypes (2 columns)
mat.geno <- matrix(NA, nrow = nrow(genotype), ncol = 2*ncol(genotype))
imp <- seq(1,ncol(mat.geno),2)
2*ncol(genotype)
# Divide each genotype (coded A/A) into 2 columns
for (i in c(1:ncol(genotype))) {
tmp <- strsplit(genotype[,i], split = '/', fixed = T)
M <- t(mapply(FUN = function(X) {X}, tmp))
mat.geno[,(imp[i]:(imp[i]+1))] <- M
}
tmp <- strsplit(genotype[,i], split = '/', fixed = T)
tmp
M <- t(mapply(FUN = function(X) {X}, tmp))
mat.geno[,(imp[i]:(imp[i]+1))] <- M
mat.geno[,(imp[i]:(imp[i]+1))]
# Create the genotype matrix for new coding genotypes (2 columns)
mat.geno <- matrix(NA, nrow = nrow(genotype), ncol = 2*ncol(genotype))
imp <- seq(1,ncol(mat.geno),2)
i <- 1
tmp <- strsplit(genotype[,i], split = '/', fixed = T)
M <- t(mapply(FUN = function(X) {X}, tmp))
t(mapply(FUN = function(X) {X}, tmp))
M <- as.matrix(M)
tmp
mapply(FUN = function(X) {X}, tmp)
M <- matrix(unlist(tmp), ncol = 2, byrow = T)
View(M)
View(tmp)
#' @keywords assignment APIS
#' @return pedigree
#' @return a log file
#' @examples data("genotype_APIS")
#'
#' result <- APIS(off.genotype = off_full,
#'                sire.genotype = sire_full,
#'                dam.genotype = dam_full,
#'                error = 0.05)
#' @export
APIS <- function(off.genotype, sire.genotype, dam.genotype, error = 0, exclusion.threshold = ncol(off.genotype), preselect.Parent = F) {
# Check inputs
#	Check if all genotypes matrices have the same number of markers
if (ncol(off.genotype) == ncol(sire.genotype) & ncol(off.genotype) == ncol(dam.genotype) & ncol(sire.genotype) == ncol(dam.genotype)) {
cat("genotype matrices : OK")
cat('\n')
} else {
stop("Your genotype matrices do not have the same number of markers")
}
#	Check if the number of mismatches allowed is lower than the number of markers and positive
if ((0 <= exclusion.threshold) && (exclusion.threshold <= ncol(off.genotype))) {
cat("exclusion threshold : OK")
cat('\n')
} else {
stop("The exclusion threshold is greater than the number of markers")
}
# Check if the user-defined assignment error rate limit is a percentage
if ((0 <= error) && (error <= 100) && (is.numeric(error))) {
cat("assignment error rate : OK")
cat('\n')
} else {
stop("The assignment error rate limit is NEGATIVE")
}
# Check if all offspring markers have at least one genotype
offspring.markerGeno <- apply(off.genotype, 2, function(X) {if (length(X[which(X != "NA/NA")]) == length(X)) {
return(T)
} else {
return(F)
}})
# Calculate the theoretical assignment power
P <- assignmentPower(sire = sire.genotype, dam = dam.genotype)
P2 <- substr(as.character(100 * P), 1, 6)
cat("The assignment power of your marker set is ", P2, "%", sep = "")
cat('\n')
if (P >= 0.99) {
cat("Theoretical assignment power : OK")
cat('\n')
} else {
message("WARNING! Your marker set is not enough powerfull!")
}
# Assign with APIS
assignResult 	<- assignmentFortran(offspring = off.genotype,
sire = sire.genotype,
dam = dam.genotype,
thresh = exclusion.threshold,
preselect.Parent = preselect.Parent)
apisResult 		<- setThreshold(ped.log = assignResult$log.mendel, ped.exclu = assignResult$exclu, nb.mrk = assignResult$nb.mrk, error = error)
pedigree 	<- apisResult$pedigree
log 		  <- apisResult$log
# Give recommendations according to the data set and the results
cat('--------------------------------------', sep = '\n')
cat('             APIS SUMMARY', sep = '\n')
cat('--------------------------------------', sep = '\n')
cat('Theoretical assignment power of the marker set : ', P2, "%", sep = "")
cat('\n')
cat('Assignment error rate accepted : ', error)
cat('\n')
assignmentRate <- length(pedigree$sire[which(is.na(pedigree$sire) == F)]) / nrow(pedigree)
AR <- substr(as.character(100 * assignmentRate), 1, 6)
cat('Assignment rate : ', AR, '%', sep = "")
cat('\n')
# Return outputs
output <- list(pedigree = pedigree, log = log, error = error)
}
library("APIS", lib.loc="~/R/win-library/3.4")
off.genotype <- APIS::off_full
# Check if all offspring markers have at least one genotype
offspring.markerGeno <- apply(off.genotype, 2, function(X) {if (length(X[which(X != "NA/NA")]) == length(X)) {
return(T)
} else {
return(F)
}})
marker_nonGeno <- offspring.markerGeno[which(offspring.markerGeno)]
marker_nonGeno <- offspring.markerGeno[which(offspring.markerGeno == T)]
marker_nonGeno <- which(offspring.markerGeno == T)
View(off.genotype)
offspring.markerGeno <- apply(off.genotype, 2, function(X) {if (length(X[which(X == "NA/NA")]) == length(X)) {
return(T)
} else {
return(F)
}})
marker_nonGeno <- which(offspring.markerGeno == T)
marker_nonGeno
marker_nonGeno == 0
off.genotype <- off.genotype[,-marker_nonGeno]
marker_nonGeno <- which(offspring.markerGeno == T)
off.genotype <- APIS::off_full
marker_nonGeno
marker_nonGeno == NULL
length(marker_nonGeno) == 0
offspring.markerGeno <- apply(off.genotype, 2, function(X) {if (length(X[which(X == "NA/NA")]) == length(X)) {
return(T)
} else {
return(F)
}})
marker_nonGeno <- which(offspring.markerGeno == T)
if (length(marker_nonGeno) == 0) {
cat("All the markers are genotyped")
cat('\n')
} else {
off.genotype <- off.genotype[, -marker_nonGeno]
cat(paste0("marker(s) ", marker_nonGeno, "have not genotypes "))
}
rm(list = ls())
library(stringr)
setwd("C:/Users/rgriot/Desktop/Publication/APIS/")
data <- read.csv2('test_dataset.csv')
data <- data[-(1:98),1:11]
data <- na.omit(data)
data$data.set <- as.character(data$data.set)
data$genotypingError <- sapply(strsplit(data$data.set, split = "_"), FUN = function(X) { return(X[[3]][1])})
# Calcul des mesures interm?diaires
data$type1 <- data$N2 + data$N4
data$type2 <- data$N3
# Mise en forme pour graphique
dataPlot <- matrix(NA, nrow = 4 * nrow(data), ncol = 6)
colnames(dataPlot) <- c("genotypingError", "miss", "power", "APISparam", "classification", "assignmentRate")
dataPlot <- as.data.frame(dataPlot)
r <- 1
for (i in 1:nrow(data)) {
truePositive    <- c(as.character(data[i, 12]), as.character(data[i, 4]), as.character(data[i, 3]), as.character(data[i, 5]), "truePositive", as.numeric(data[i, 7]))
trueNegative    <- c(as.character(data[i, 12]), as.character(data[i, 4]), as.character(data[i, 3]), as.character(data[i, 5]), "trueNegative", as.numeric(data[i, 11]))
falsePositive   <- c(as.character(data[i, 12]), as.character(data[i, 4]), as.character(data[i, 3]), as.character(data[i, 5]), "type1", as.numeric(data[i, 13]))
falseNegative   <- c(as.character(data[i, 12]), as.character(data[i, 4]), as.character(data[i, 3]), as.character(data[i, 5]), "type2", as.numeric(data[i, 14]))
dataPlot[r, ] <- truePositive
r <- r + 1
dataPlot[r, ] <- trueNegative
r <- r + 1
dataPlot[r, ] <- falsePositive
r <- r + 1
dataPlot[r, ] <- falseNegative
r <- r + 1
}
dataPlot$assignmentRate <- as.numeric(as.character(dataPlot$assignmentRate)) / 10
# fichier pour plot
library(ggplot2)
library(gridExtra)
temp <- aggregate(list(assignmentRate = dataPlot$assignmentRate),
list(APIS_param = dataPlot$APISparam, miss = dataPlot$miss, geno_error = dataPlot$genotypingError, classification = dataPlot$classification),
mean)
temp$miss <- as.factor(temp$miss)
levels(temp$miss) <- c("0% of missing sires", "10% of missing sires", "50% of missing sires")
temp$APIS_param <- as.factor(temp$APIS_param)
levels(temp$APIS_param) <- c("APIS1", "APIS5")
temp$geno_error <- as.factor(temp$geno_error)
levels(temp$geno_error) <- c("1% of genotyping errors", "3% of genotyping errors")
temp$classification <- as.factor(temp$classification)
levels(temp$classification) <- c("true negative", "true positive", "type I error", "type II error")
classOrder <- c("type II error", "type I error", "true negative", "true positive")
temp$classification <- factor(temp$classification, levels = classOrder)
View(temp)
library(APIS)
library(APIS)
library(APIS)
data("genotype_APIS")
library(APIS)
roxygen2::roxygenize()
library(APIS)
roxygen2::roxygenize()
library(APIS)
sessionInfo()
library(APIS)
library("APIS", lib.loc="~/R/win-library/3.4")
data("genotype_APIS")
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
library(APIS)
library("APIS", lib.loc="~/R/win-library/3.4")
data("genotype_APIS")
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
sessionInfo()
install.packages("roxygen2")
library("roxygen2", lib.loc="C:/Program Files/R/R-3.6.1/library")
install.packages("devtools")
install.packages("rmarkdown")
roxygenize()
devtools::find_rtools(T)
library(APIS)
library("APIS", lib.loc="C:/Program Files/R/R-3.6.1/library")
data("genotype_APIS")
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
library(APIS)
library("APIS", lib.loc="C:/Program Files/R/R-3.6.1/library")
install.packages("doSNOW")
install.packages("foreach")
install.packages("doParallel")
install.packages("ggplot2")
install.packages("gridExtra")
library(APIS)
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
install.packages("parallel")
library("parallel", lib.loc="C:/Program Files/R/R-3.6.1/library")
library(APIS)
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
library("doSNOW", lib.loc="C:/Program Files/R/R-3.6.1/library")
library(APIS)
result <- APIS(off.genotype = off_full,
sire.genotype = sire_full,
dam.genotype = dam_full,
error = 0.05)
rm(list = ls())
setwd("C:/Users/rgriot/Desktop/Publication/APIS/package/exemple")
offspring.genotype_100mrk <- read.table('offspring_genotype.txt')
sire.genotype_100mrk <- read.table('sire_genotype.txt')
dam.genotype_100mrk <- read.table('dam_genotype.txt')
APIS_100markers <- list(
offspring = offspring.genotype_100mrk,
sire = sire.genotype_100mrk,
dam = dam.genotype_100mrk
)
setwd("D:/Data_RG/package_APIS/APIS")
use_data(APIS_100markers, pkg ="D:/Data_RG/package_APIS/APIS")
library(devtools)
library(roxygen2)
use_data(APIS_100markers, pkg ="D:/Data_RG/package_APIS/APIS")
APIS_100markers
setwd("D:/Data_RG/package_APIS/APIS")
use_data(APIS_100markers, pkg ="D:/Data_RG/package_APIS/APIS")
assign(APIS_100markers, "APIS_100markers")
install.packages("purrr")
library(purrr)
names(APIS_100markers)
setwd("D:/Data_RG/package_APIS/APIS")
walk2(APIS_100markers, names(APIS_100markers), function(obj, name) {
assign(name, obj)
do.call("use_data", list(as.name(name), overwrite = TRUE))
})
roxygenize()
roxygenize()
setwd("D:/Data_RG/package_APIS/APIS/R")
load("D:/Data_RG/package_APIS/APIS/data/offspring.rda")
rm(list = ls())
setwd("C:/Users/rgriot/Desktop/Publication/APIS/package/exemple")
offspring.genotype_100mrk <- as.matrix(read.table('offspring_genotype.txt'))
sire.genotype_100mrk <- as.matrix(read.table('sire_genotype.txt'))
dam.genotype_100mrk <- as.matrix(read.table('dam_genotype.txt'))
APIS_100markers <- list(
offspring = offspring.genotype_100mrk,
sire = sire.genotype_100mrk,
dam = dam.genotype_100mrk
)
setwd("D:/Data_RG/package_APIS/APIS")
walk2(APIS_100markers, names(APIS_100markers), function(obj, name) {
assign(name, obj)
do.call("use_data", list(as.name(name), overwrite = TRUE))
})
library(APIS)
data("offspring")
rm(list = ls())
setwd("C:/Users/rgriot/Desktop/Publication/APIS/package/exemple")
offspring.genotype_100mrk <- as.matrix(read.table('offspring_genotype.txt'))
sire.genotype_100mrk <- as.matrix(read.table('sire_genotype.txt'))
dam.genotype_100mrk <- as.matrix(read.table('dam_genotype.txt'))
APIS_100markers <- list(
APIS_offspring = offspring.genotype_100mrk,
APIS_sire = sire.genotype_100mrk,
APIS_dam = dam.genotype_100mrk
)
setwd("D:/Data_RG/package_APIS/APIS")
walk2(APIS_100markers, names(APIS_100markers), function(obj, name) {
assign(name, obj)
do.call("use_data", list(as.name(name), overwrite = TRUE))
})
library(APIS)
data("APIS_offspring")
data("APIS_dam")
data("APIS_sire")
result <- APIS(off.genotype = APIS_offsping,
sire.genotype = APIS_sire,
dam.genotype = APIS_dam,
error = 0.05)
sessionInfo()
rm(list = ls())
library(data.table)
set.seed(20)
setwd("D:/Data_RG/Package_Assignation_nouveau/Package_Assignation_nouveau/Data")
off.genotype <- fread('off_FMD.txt')
dam.genotype <- fread('dam_FMD.txt')
sire.genotype <- fread('sir_FMD.txt')
setwd("D:/Data_RG/Package_Assignation_nouveau/Package_Assignation_nouveau/Data/resampling/")
vrai.ped <- read.table('ped_vrai_FMD.txt', sep = " ", header = T)
offspring_tokeep <- as.character(vrai.ped$off[which(vrai.ped$assign == "assigne")])
off.genotype <- off.genotype[which(off.genotype$ID %in% offspring_tokeep),]
off.genotype.matrix <- as.matrix(off.genotype)
rownames(off.genotype.matrix) <- off.genotype.matrix[, 1] ; off.genotype.matrix <- off.genotype.matrix[, -1]
dam.genotype.matrix <- as.matrix(dam.genotype)
rownames(dam.genotype.matrix) <- dam.genotype.matrix[, 1] ; dam.genotype.matrix <- dam.genotype.matrix[, -1]
sire.genotype.matrix <- as.matrix(sire.genotype)
rownames(sire.genotype.matrix) <- sire.genotype.matrix[, 1] ; sire.genotype.matrix <- sire.genotype.matrix[, -1]
# Meilleurs marqueurs
# MAF <- allFreq(off.genotype.matrix)
# MAF <- as.data.frame(MAF)
# MAF$maf <- pmin(MAF$Freq_A, MAF$Freq_B)
# MAF2 <- MAF[order(MAF$maf, decreased = T),]
#
# mrk_list <- rownames(MAF2)[1:200]
# Random
mrk_list <- colnames(off.genotype.matrix)[sample(c(1:ncol(off.genotype.matrix)), 500)]
# Preparation des fichiers d'entree
offspring.genotype <- off.genotype.matrix[, which(colnames(off.genotype.matrix) %in% mrk_list)]
sire.genotype <- sire.genotype.matrix[, which(colnames(sire.genotype.matrix) %in% mrk_list)]
dam.genotype <- dam.genotype.matrix[, which(colnames(dam.genotype.matrix) %in% mrk_list)]
# ASSIGNATION
library(APIS)
result <- APIS(off.genotype = offspring.genotype,
dam.genotype = dam.genotype,
sire.genotype = sire.genotype[sample(c(1:39), 20),],
error = 0.05)
