#' assignment
#'
#' This function calculates the average Mendelian transmission probabilities
#' @param offspring Offspring genotypes | Matrix (n*p) where n = number of individuals, p = number of markers
#' rownames(offspring) = labels of offspring
#' marker coding = "All1/All2" example: "A/A", "A/B", "NA/NA" (for missing genotype)
#' @param sire Sire genotypes | Matrix (n*p) where n = number of individuals, p = number of markers
#' rownames(sire) = labels of sires
#' marker coding = "All1/All2" example: "A/A", "A/B", "NA/NA" (for missing genotype)
#' @param dam Dam genotypes | Matrix (n*p) where n = number of individuals, p = number of markers
#' rownames(dam) = labels of dams
#' marker coding = "All1/All2" example: "A/A", "A/B", "NA/NA" (for missing genotype)
#' @param thresh (default: ncol(offspring) Threshold for exclusion (number of mismatches allowed)
#' @keywords assignment
#' @export pedigree Matrix of pedigree before APIS threshold process
#' @export log.like Dataframe with the log of Mendelian transmission probabilities and likelihood calculation
#' @export log.exclu Dataframe with the log of exclusion process
#' @export nb.mrk Number of markers used

assignment <- function(offspring, sire, dam, thresh = ncol(offspring)) {
  # DESCRIPTION
  # Function to calculate average Mendelian transmission probabilities


  # Import packages
  require(doParallel)
  require(foreach)

  # Stop if different number of markers are provided
  if (ncol(offspring)!=ncol(siree)&ncol(offspring)!=ncol(dam))
    stop('Genotypes must have the same number of markers')

  # Create the results matrix
  ped <- matrix(NA, nrow = nrow(offspring), ncol = 7)
  colnames(ped) <- c('off', 'sire1', 'dam1', 'nb_exclu1', 'log_like1', 'P_mendel1', 'assign')
  ped[,1] <- rownames(offspring)

  ped.log <- as.data.frame(matrix(NA,nrow = nrow(offspring), ncol = 21))
  colnames(ped.log) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1', 'like1', 'mendel1',
                         'sire2', 'dam2', 'miss2', 'like2', 'mendel2', 'delta_like12', 'delta_Pmendel12',
                         'sire3', 'dam3', 'miss3', 'like3', 'mendel3', 'delta_like23', 'delta_Pmendel23')
  ped.log[,1] <- rownames(offspring)
  ped.log[,2] <- as.numeric(apply(offspring,1, function(X) {length(X[X!='NA/NA'])}))

  ped.exclu <- as.data.frame(matrix(NA, nrow = nrow(offspring), ncol = 11))
  colnames(ped.exclu) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1',
                           'sire2', 'dam2', 'miss2',
                           'sire3', 'dam3', 'miss3')

  # Parameters
  e <- 0.01 # Genotyping error of 1%

  # Estimate allele frequencies
  setwd("C:/Users/rgriot/Dropbox/phD/Assignation")
  source('allFreq.R')
  cat('Estimation of allele frequencies')
  cat('\n')
  Freq <- CalcFreq(offspring)

  x.col <- ncol(offspring)

  # Exclusion tables
  homo_exclu <- matrix(c(0,0,1,0,
                         0,0,1,0,
                         1,1,2,1,
                         0,0,1,0), nrow = 4, ncol = 4)
  rownames(homo_exclu) <- c('AA', 'AC', 'CC', 'miss')
  colnames(homo_exclu) <- c('AA', 'AC', 'CC', 'miss')

  hetero_exclu <- matrix(c(1,0,0,1,0,1,0,
                           0,0,0,0,0,1,0,
                           0,0,1,0,1,1,0,
                           1,0,0,1,0,1,0,
                           0,0,1,0,1,1,0,
                           1,1,1,1,1,2,1,
                           0,0,0,0,0,1,0), nrow = 7, ncol = 7)
  rownames(hetero_exclu) <- c('AA', 'AB', 'BB', 'AC', 'BC', 'CC', 'miss')
  colnames(hetero_exclu) <- c('AA', 'AB', 'BB', 'AC', 'BC', 'CC', 'miss')

  cat('Assignment')
  cat('\n')

  # Set up the cluster for parallel iteration
  cl <- makeCluster(detectCores()-1)
  registerDoParallel(cl)

  # Start
  A <- foreach(off=1:nrow(offspring), .multicombine = T,
               .packages = c('foreach', 'doParallel')) %dopar% { # For each offspring
    tmp <- offspring[off,, drop = F]

    # Create temporary results
    res <- matrix(NA, nrow = (nrow(sire)*nrow(dam)), ncol = 5)
    colnames(res) <- c('sire', 'dam', 'score_exclu', 'score_like', 'P_mendel')
    res[,1] <- rep(rownames(sire), each = nrow(dam))
    res[,2] <- rep(rownames(dam), times = nrow(sire))

    # Lielihood tables
    table_like <- vector('list', x.col)
    off_geno <- strsplit(tmp, split = "/", fixed = T)
    for (i in 1:length(tmp)) {
      if (off_geno[[i]][1]==off_geno[[i]][2]) {
        fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
        fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
        table_like[[i]] <- matrix(c(1,0.5,e,fa,0.5,0.25,e,0.5*fa,e,e,e,e,fa,0.5*fa,e,fa*fa), nrow = 4, ncol = 4)
      } else {
        fa <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][1]))]
        fa <- ifelse(test = (fa==0|is.na(fa)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fa)
        fb <- Freq[i,which(colnames(Freq)==paste0('Freq_',off_geno[[i]][2]))]
        fb <- ifelse(test = (fb==0|is.na(fb)), yes = Freq[i,which(colnames(Freq)==paste0('Freq_NA'))], no = fb)

        table_like[[i]] <- matrix(c(e,0.5,1,e,0.5,e,fb,
                                    0.5,0.5,0.5,0.25,0.5,e,0.5*(fa+fb),
                                    1,0.5,e,0.5,e,e,fa,
                                    e,0.25,0.5,e,0.25,e,0.5*fb,
                                    0.5,0.25,e,0.25,e,e,0.5*fb,
                                    e,e,e,e,e,e,e,
                                    fb,0.5*(fa+fb),fa,0.5*fb,0.5*fa,e,2*fa*fb), nrow = 7, ncol = 7)
      }
    }

    t <- foreach(n = 1:nrow(res), .combine = rbind,
                 .multicombine = T, .packages = c('foreach', 'doParallel')) %dopar% { # For each parents pair

      #p = siree // m = dam
      p <- sire[which(rownames(sire)==res[n,1]),, drop = F]
      m <- dam[which(rownames(dam)==res[n,2]),, drop = F]

      # Keep likelihood and missmatches
      sc_exclu <- vector(mode = 'numeric', length = x.col)
      sc_like <- vector(mode = 'numeric', length = x.col)

      off_split <- strsplit(tmp, split = "/", fixed = T)
      p_split <- strsplit(p, split = "/", fixed = T)
      m_split <- strsplit(m, split = "/", fixed = T)

      mrk <- 1

      while (mrk <= x.col & sum(sc_exclu) <= thresh) { # For each marker
        off_mrk <- off_split[[mrk]]
        p_mrk <- p_split[[mrk]]
        m_mrk <- m_split[[mrk]]

        if (off_mrk[1]=='NA'&off_mrk[2]=='NA') { # if offspring genotype is missing
          sc_exclu[mrk] <- 0
          sc_like[mrk] <- 1
        } else if (off_mrk[1]==off_mrk[2]&off_mrk[1]!='NA') { #If offspring is HOMOZYGOUS
          # SIRE ID
          if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
            if (p_mrk[1]=='NA') {
              p_id <- 4 # sire NA/NA
            }else if (p_mrk[1]==off_mrk[1]) {
              p_id <- 1 # sire A/A
            } else {
              p_id <- 3 # sire "C/C"
            }
          } else { # If the sire is HETEROZYGOUS
            if ((p_mrk[1]!=off_mrk[1]&p_mrk[2]!=off_mrk[1])&(p_mrk[1]!=off_mrk[2]&p_mrk[2]!=off_mrk[2])) {
              p_id <- 3 # sire C/C
            } else {
              p_id <- 2 # sire A/C
            }
          }
          #DAM ID
          if (m_mrk[1]==m_mrk[2]) { #If the dam is HOMOZYGOUS
            if (m_mrk[1]=='NA') {
              m_id <- 4 # dam NA/NA
            }else if (m_mrk[1]==off_mrk[1]) {
              m_id <- 1 # dam A/A
            } else {
              m_id <- 3 # dam C/C
            }
          } else { # If the dam is HETEROZYGOUS
            if ((m_mrk[1]!=off_mrk[1]&m_mrk[2]!=off_mrk[1])&(m_mrk[1]!=off_mrk[2]&m_mrk[2]!=off_mrk[2])) {
              m_id <- 3 # dam C/C
            } else {
              m_id <- 2 # dam A/C
            }
          }

          sc_exclu[mrk] <- homo_exclu[m_id,p_id]
          sc_like[mrk] <- table_like[[mrk]][m_id, p_id]

        } else { #If the offspring is HETEROZYGOUS
          # SIRE ID
          if (p_mrk[1]==p_mrk[2]) { # If the sire is HOMOZYGOUS
            if (p_mrk[1]=='NA') {
              p_id <- 7 # sire NA/NA
            }else if (p_mrk[1]==off_mrk[1]) {
              p_id <- 1 # sire A/A
            } else if (p_mrk[1]==off_mrk[2]) {
              p_id <- 3 # sire B/B
            } else {
              p_id <- 6 # sire C/C
            }
          } else { # If the sire is HETEROZYGOUS
            if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
              p_id <- 2 # sire A/B
            } else if ((p_mrk[1]==off_mrk[1]|p_mrk[2]==off_mrk[1])&(p_mrk[1]!=off_mrk[2]|p_mrk[2]!=off_mrk[2])){
              p_id <- 4 # sire A/C
            } else if ((p_mrk[1]!=off_mrk[1]|p_mrk[2]!=off_mrk[1])&(p_mrk[1]==off_mrk[2]|p_mrk[2]==off_mrk[2])) {
              p_id <- 5 # sire B/C
            } else {
              p_id <- 6 # sire C/C
            }
          }

          # DAM ID
          if (m_mrk[1]==m_mrk[2]) { # If the dam is HOMOZYGOUS
            if (m_mrk[1]=='NA') {
              m_id <- 7 # dam NA/NA
            }else if (m_mrk[1]==off_mrk[1]) {
              m_id <- 1 # dam A/A
            } else if (m_mrk[1]==off_mrk[2]) {
              m_id <- 3 # dam B/B
            } else {
              m_id <- 6 # dam C/C
            }
          } else { # If the dam is HETEROZYGOUS
            if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
              m_id <- 2 # dam A/B
            } else if ((m_mrk[1]==off_mrk[1]|m_mrk[2]==off_mrk[1])&(m_mrk[1]!=off_mrk[2]|m_mrk[2]!=off_mrk[2])){
              m_id <- 4 # dam A/C
            } else if ((m_mrk[1]!=off_mrk[1]|m_mrk[2]!=off_mrk[1])&(m_mrk[1]==off_mrk[2]|m_mrk[2]==off_mrk[2])) {
              m_id <- 5 # dam B/C
            } else {
              m_id <- 6 # dam C/C
            }
          }

          # Get the score for tested marker
          sc_exclu[mrk] <- hetero_exclu[m_id,p_id]
          sc_like[mrk] <- table_like[[mrk]][m_id, p_id]
        }

        mrk <- mrk + 1

      }

      # Create the parallel loop output
      r <- c(NA,NA,NA)
      r[1] <- sum(sc_exclu) # Number of missmatch
      r[2] <- sum(log(sc_like)) # Log likelihood
      r[3] <- exp(sum(log(sc_like))/ped.log[off,2]) # Mendelian transimission probability

      return(r)
    }

    # Working of the results
    res[,3:5] <- t
    res <- as.data.frame(res)
    res$sire <- as.character(res$sire)
    res$dam <- as.character(res$dam)
    res$score_exclu <- as.numeric(as.character(res$score_exclu))
    res$score_like <- as.numeric(as.character(res$score_like))
    res$P_mendel <- as.numeric(as.character(res$P_mendel))

    # Order by Mendelian transmission probabilities
    res2 <- res[order(res[,5], res[,3], decreasing = T),]
    res2 <- res2[which(res2$P_mendel!=-Inf),]

    delta_log12 <- res2[1,4]-res2[2,4]
    delta_log23 <- res2[2,4]-res2[3,4]

    delta_P12 <- res2[1,5]-res2[2,5]
    delta_P23 <- res2[2,5]-res2[3,5]

    p_fin <- res2[1,1]
    m_fin <- res2[1,2]

    ped.out <- c(rownames(tmp),NA,NA,NA,NA,NA)
    if (is.na(p_fin)&is.na(m_fin)) {
      ped.out[2:3] <- c('no_match', 'no_match')
      ped.out[4:6] <- c(NA, NA, NA)
    } else {
      ped.out[2:3] <- c(p_fin,m_fin)
      nb_exclu <- res2[which(res2$sire==p_fin&res2$dam==m_fin),3]
      ped.out[4:6] <- c(nb_exclu, res2[1,4], res2[1,5])
    }

    log.out <- unlist(c(ped.out[1], ped.log[off,2],ped.out[2:6], res2[2,1:5], delta_log12, delta_P12, res2[3,1:5], delta_log23, delta_P23))

    cat("\r", off, "on", nrow(offspring))

    # Order by mismatches
    res2 <- res[order(res[,3], -res[,4], decreasing = F),]
    res2 <- res2[which(res2$score_like!=-Inf),]


    exclu.out <- unlist(c(log.out[1],ped.log[off,2], res2[1,1:3], res2[2,1:3], res2[3,1:3]))

    a <- list(ped.out, log.out, exclu.out)
  }

  # Stop the parallel cluster
  stopCluster(cl)

  ped <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[1]]}))))
  colnames(ped) <- c('off', 'sire1', 'dam1', 'nb_exclu1', 'log_like1', 'P_mendel1')
  rownames(ped) <- c(1:nrow(ped))

  # Working on the data
  ped$off <- as.character(ped$off)
  ped$sire1 <- as.character(ped$sire1)
  ped$dam1 <- as.character(ped$dam1)
  ped$nb_exclu1 <- as.numeric(as.character(ped$nb_exclu1))
  ped$log_like1 <- as.numeric(as.character(ped$log_like1))
  ped$P_mendel1 <- as.numeric(as.character(ped$P_mendel1))

  # Create a log
  ped.log <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[2]]}))))
  colnames(ped.log) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1', 'like1', 'mendel1',
                         'sire2', 'dam2', 'miss2', 'like2', 'mendel2', 'delta_like12', 'delta_Pmendel12',
                         'sire3', 'dam3', 'miss3', 'like3', 'mendel3', 'delta_like23', 'delta_Pmendel23')
  rownames(ped.log) <- c(1:nrow(ped.log))
  ped.log[,] <- sapply(ped.log[,c(1:ncol(ped.log))], as.character)
  ped.log[,c(2,5:7,10:14, 17:21)] <- sapply(ped.log[,c(2,5:7,10:14, 17:21)], as.numeric)

  # Create a data frame from results by exclusion
  ped.exclu <- as.data.frame(t(as.data.frame(lapply(A, function(X) {t <- X[[3]]}))))
  colnames(ped.exclu) <- c('off', 'mrk_genotype','sire1', 'dam1', 'miss1',
                           'sire2', 'dam2', 'miss2',
                           'sire3', 'dam3', 'miss3')
  rownames(ped.exclu) <- c(1:nrow(ped.exclu))
  ped.exclu[,c(2,5,8,11)] <- sapply(ped.exclu[,c(2,5,8,11)], as.numeric)

  # Return the output
  return(list(pedigree = ped, log.mendel = ped.log, log.exclu = ped.exclu, nb.mrk = ncol(offspring)))
}
